This proposal is a mostly a list of ideas thrown together, there is much to discuss. Basically, the goal is to add support for multiple workspaces, add flexibility on authentication and make it easier to implement at scale.

## Terms

- Chat Users: refers to users speaking with a bot (which may or may not be authenticated)
- Collaborators: Authenticated users on the studio

## Summary of proposed changes

- Adds support for multiple workspaces (a workspace has custom user roles and hosts multiple bots)
- Remove collaborators from "workspaces.json" and move them to the database
- Collaborators accounts are global (may be in one or more workspaces)
- Extract "Auth Strategies" from botpress config into its own file (there could be multiple basic auth or saml auth config)
- Users would be authenticated by a UUID, so there could be multiple different tables for different auth strategies
- Add a new skill, "Authentication Gate", which would let the user through if he's authenticated, or force him to authenticate.
- Add an "Auth Strategy" property optionally to each bots. It will be used when faced with an Authentication Gate
- Add a generic route /callback to handle SAML calls for studio login / bot login (should also have one for basic auth)

## Scenarios

- An unauthenticated user opens the Admin page. He enters his credentials, and is either redirected to 1) his only available workspace, 2) the one specified in the url or 3) a list of his workspaces,

- An unauthenticated user speaks with a bot having LDAP or SAML configured, and stumble upon an Authentication Gate. The skill sees that the user is not authenticated, he generates a session id (including the auth strategy data), then generates an url with that info, and sends it to the user via a Carousel card. Once the user enters his info, the provider hits the callback at :3000/auth/callback, the session is set in the KVS, and the user may speak with the bot.

- An unauthenticated user speaks with a bot which has a Basic auth configured. If the channel supports it, it will display a username/password form with a send button. When the user sends the form,
  it makes a call to the module's backend. If the channel doesn't support it, we could send him to a standard HTML page (assets in channel web), then poke the backend for authentication (using sdk?)

- A user authenticated on the Studio with access to the bot. I think he should be restricted as any other user, since he probably wants to have his attributes / permissions when testing the bot. Also, the auth policy of the bot could be set to the "global" one of the admin, which means his collaborator account

## Create a global file named `auth_strategies.json`

To allow for more flexibility, we should remove the auth strategy from the botpress config and move it to its own file. There could be multiple different strategies configured this way.
They would be managed by Super Admins. When creating a bot, the collaborator could pick an authentication strategy in the "public list"

There could be multiple basic strategies, each using a different table in the database. This could be possible if we use UUID to identify users and map them to their workspaces.
Each strategy should have a "table" parameter, which indicates where the users are stored. The same table could be used for all strategies, or different ones.

### Example Strategy file

```js
;[
  {
    id: 'default',
    type: 'basic',
    options: {
      maxLoginAttempt: 3
    },
    table: 'collaborators',
    public: true
  },
  {
    id: 'external_users',
    type: 'basic',
    table: 'collaborators',
    public: true
  },
  {
    id: 'saml_external',
    type: 'saml',
    options: {
      authEndpoint: 'http://external.com'
    },
    source: 'saml_private',
    fieldMapping: []
  }
]
```

## Verification

### Current Setup

Admin:
The user authenticates using the AuthService method. He uses the specified provider configured, then a JWT token is generated and added as header "Authorization: Bearer"
That token is validated each time the backend received a request (it only contains the email and if the user is a Super Admin)

Bot:
The user gets a token generated by an external source. He sends it as header "x-bp-externalauth" with each request on channel-web. We use the publicKey defined in botpress.config.json to validate it, then set the "event.credentials" value to the decrypted payload.

### Suggested

Admin:
Similar, but we would also add the auth strategy used in the JWT token

Bot:
Once the user logs on (whichever strategy being used), we store the email, auth strategy & other infos in a JWT token, which is assigned to himself (channel, target, botId, threadId) in the KVS.

On each incoming event, we check the validity of the given token (auth strategy, expiration, etc) then set the "credentials" property on the event. This is used by the Authentication Gate

## Table Structure

### collaborators / users

uuid | username | auth_strategy | password | salt | attributes | created_on | modified_on

-> Primary key = id OR username + auth_strategy

### workspace_users

user_uuid | workspace_id | role
